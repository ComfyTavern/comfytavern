# 统一应用模板架构方案 (Unified App Template Architecture)

## 1. 方案目标

本方案旨在为ComfyTavern设计并实现一套完整的**项目模板系统 (Project Template System)**。该系统将允许平台（以及未来可能的社区）提供预打包、功能完整的项目蓝图，用户可以通过简单的选择和配置，快速基于模板创建一个内容丰富、开箱即用的AI应用项目。

这是ComfyTavern从一个纯粹的专业工具，向一个**易于上手、体验驱动的应用平台**演进的关键一步。

## 2. 核心概念与用户流程

### 2.1 什么是应用模板？

一个“项目模板”是一个只读的、遵循ComfyTavern项目结构的**项目蓝图 (Project Blueprint)**。其本质是一个包含了创建特定类型应用所需的所有预设资产的目录结构，例如一个预先配置好的 `project.json` 文件、相关的工作流、知识库、Agent Profile 定义、以及 UI 面板等。

### 2.2 用户核心流程

1.  **发现 (Discovery)**: 用户在ComfyTavern主界面点击“创建新项目”。
2.  **选择 (Selection)**: 系统弹出一个“模板浏览器”，展示所有可用的**项目模板**。
3.  **实例化 (Instantiation)**: 用户选择一个模板并为新项目命名。后端服务会将该模板的完整内容复制到用户的项目空间，从而创建一个全新的、独立的、完全可编辑的 **ComfyTavern 项目**。
4.  **引导 (Onboarding)**: 项目创建成功后，系统自动打开该项目，并可以根据模板的预设（例如 `project.json` 中的 `preferredView` 或 `default_scene_id`），自动加载一个场景并显示预设的 UI 面板。

## 3. 旗舰范例：“交互式RPG框架”

为了展示项目模板系统的真正潜力，我们定义了一个旗舰级的模板范例：“交互式RPG框架”。它旨在解决SillyTavern等平台在构建复杂RPG时遇到的核心瓶颈。

### 3.1 定位：从“聊天模拟器”到“真正的游戏工作台”

此模板的核心价值在于将ComfyTavern定位为一个**强大的游戏创作与运行平台**。它提供的不是一个简单的聊天框，而是一个**持久化的、可高度定制的交互式游戏仪表盘 (Dashboard)**，该仪表盘可以工作在两种模式下：
- **直接调用模式 (Direct Invocation)**: 面板直接调用工作流，不依赖场景，实现快速、轻量的核心功能。
- **场景驱动模式 (Scene-driven)**: 面板作为场景的一部分运行，与Agent和世界状态深度交互，实现完整的、沉浸式的游戏体验。
这种双模支持为用户创造了压倒性的迁移价值和灵活的开发路径。

### 3.2 核心特色

#### A. 双模驱动的仪表盘 (Dual-Mode Dashboard)

这是模板的灵魂，一个状态化、持久化的游戏主界面，它被设计为可以在两种模式下无缝工作。

-   **技术选型**: 此仪表盘作为一个**应用面板 (Application Panel)**，可以采用**原生Vue页面组件** (`runtimeType: "native"`) 以保证极致性能和复杂的交互逻辑。
-   **布局范例**: 包含主视觉区、角色状态面板、物品栏、事件日志和交互按钮区。

-   **模式一：直接调用 (Direct Invocation Mode)**
    -   **启动方式**: 当项目的 `project.json` 中设置了 `default_panel_id` 且没有 `default_scene_id` 时，面板被直接加载。
    -   **交互逻辑**: 面板通过 `panelApi` 直接调用项目中的特定工作流（例如 `workflow-skill-check.json`），并自行管理返回结果和UI状态。此模式下，它不依赖场景的事件总线或世界状态。
    -   **适用场景**: 实现核心功能先行，快速原型验证，或提供轻量级的、无状态的工具体验。

-   **模式二：场景驱动 (Scene-driven Mode)**
    -   **启动方式**: 当项目加载了一个场景（例如，通过 `default_scene_id`），且该场景的 `associated_panels` 中声明了此面板时，面板作为场景的一部分被加载。
    -   **交互逻辑**: 面板通过订阅**场景的事件总线(EventBus)**与场景中的Agent和其他元素进行异步通信。用户的操作会发布事件，Agent响应事件，其行动结果再通过事件通知面板更新UI。
    -   **适用场景**: 完整的RPG体验，需要多Agent协作、持久化世界状态和复杂剧情编排。

#### B. 模块化工作流 (Modular Workflows)

将游戏中复杂的逻辑拆分为独立的、可视化的工作流。这些工作流在模板中被预定义，并可以在不同层次上被调用：
- **Agent的技能工作流 (Skill Workflows)**: 定义Agent可以执行的具体能力，如 `skill-skill-check.json` 或 `skill-update-inventory.json`。这些在 `agent_profile.json` 中被引用。
- **场景的编排工作流 (Scene Orchestration Workflows)**: 用于控制宏观剧情走向或处理不属于任何单个Agent的逻辑，例如在 `scene.json` 的 `scene_lifecycle_workflows` 中定义 `on_scene_start` 初始设置工作流。

#### C. “升维”转换引擎 (Upgraded Importer)

导入工具的目标是升级而非简单复制，将SillyTavern资产映射为更强大的ComfyTavern原生项目结构。

-   **角色核心设定** -> 转换为项目中的 `agent_profiles/character_profile.json` 文件，定义Agent的静态蓝图。
-   **长文本描述 (性格/背景)** -> 智能切分为**CAIU条目**，存入项目本地的 `knowledgebases/character_core_kb/` 知识库。
-   **示例对话/问候语** -> 转换为带特殊标签 (`#example_dialogue`, `@greeting`) 的CAIU条目，作为Agent的学习语料。
-   **世界书** -> 逐条转换为独立的知识库CAIU条目。
-   **角色属性 (`[Strength:15]`)** -> 映射到`agent_profile.json`中的`initial_private_state_values`。
-   **ST脚本/语法** -> 识别其**意图**（如检定、物品操作），并引导用户使用模板中预设的 **Agent技能工作流** 来重建逻辑。
-   **自动生成场景**: 转换器还会自动生成一个初始的 `scenes/initial_scene.json` 文件，该文件会预先配置好，用于实例化导入的角色Agent，并关联默认的RPG仪表盘面板。

### 3.3 典型用户体验流程

1.  **导入与创建**: 用户导入ST角色包。转换引擎基于“RPG框架”模板，创建一个新的、完整的**ComfyTavern项目**。
2.  **场景加载**: 用户打开项目，默认的 `initial_scene.json` 被加载，创建一个**场景实例(Scene Instance)**。
3.  **实例激活**: 场景实例根据其定义，创建并激活**Agent运行时实例 (`AgentRuntime`)** 和关联的**RPG仪表盘面板**。
4.  **交互循环 (Interaction Loop)**:
    *   用户在仪表盘上的操作（如点击“攻击”按钮）会通过 `panelApi` 向场景的**事件总线**发布一个`user_action`事件。
    *   Agent的`AgentRuntime`接收到此事件，触发其**核心审议工作流**。
    *   Agent决策后，调用一个**技能工作流**（如检定技能）。
    *   该技能工作流的执行结果（如状态变更、物品增减）会通过更新Agent的**私有状态(PrivateState)**并发布一个`agent_state_updated`**事件**来体现。
    *   仪表盘面板作为订阅者，接收到状态更新事件，并**立即、实时地**更新UI，实现真正的沉浸式体验。

## 4. 技术架构设计

### 4.1 模板存储与发现

-   **存储位置**: 官方项目模板存放于 `templates/project-templates/` 目录。
-   **发现机制**: 后端提供 `GET /api/templates/projects` 接口，扫描目录并读取每个模板的核心元数据（通常来自模板根目录下的 `project.json`）返回给前端。

### 4.2 项目实例化

-   **后端API**: `POST /api/projects`，接收 `projectName` 和 `templateId`。
-   **核心逻辑**: 后端服务递归复制模板目录到用户项目空间，创建一个完整的、独立的项目。此过程可能包括处理动态占位符（如生成新的UUID）。

### 4.3 面板加载与交互模式

为兼顾性能与灵活性，系统支持两种UI呈现方式和两种交互模式。

-   **UI呈现方式** (通过 `panel.json` 的 `runtimeType` 区分):
    1.  **原生页面 (`runtimeType: "native"`)**: 内置于主程序的Vue组件，性能最佳。
    2.  **Iframe面板 (`runtimeType: "iframe"`)**: 独立的Web内容，安全隔离，技术栈无关。

-   **前端加载逻辑与交互模式**:
    1.  **直接加载 (Direct Loading)**:
        -   当项目启动时，若 `project.json` 中定义了 `default_panel_id` 且无 `default_scene_id`，前端会直接加载该面板。
        -   此模式下，面板通过 `panelApi` 直接调用工作流 (`invokeWorkflow`)，实现**直接调用模式**。
    2.  **通过场景加载 (Scene-based Loading)**:
        -   当项目启动时，若 `project.json` 中定义了 `default_scene_id`，则加载对应场景。
        -   场景视图会根据 `scene.json` 的 `associated_panels` 列表加载所需的面板。
        -   此模式下，面板除了能直接调用工作流外，主要通过 `panelApi` 提供的事件接口 (`subscribe`, `publish`) 与场景的事件总线交互，实现**场景驱动模式**。

## 5. 方案实施路线图

### 阶段一：MVP (最小可行产品)

-   **后端**: 实现项目模板的扫描和基于模板创建项目的核心API。
-   **前端**: 实现项目模板浏览器，并确保场景视图能够正确加载和渲染模板项目中定义的面板。
-   **内容**: 创建并内置两个项目模板：
    -   一个**“交互式RPG框架”**模板，该模板同时支持**直接调用模式**（用于核心功能预览）和**场景驱动模式**（用于完整体验）。
    -   一个简单的**“工具面板”**模板，它只使用**直接调用模式**，用于展示如何快速构建一个纯粹的、无场景的工具型应用。

### 阶段二：功能增强

-   优化模板浏览器UI（搜索、筛选）。
-   支持更复杂的模板变量替换。
-   开发更多官方模板。

### 阶段三：生态与社区

-   设计并实现社区项目模板的提交流程和管理机制。
-   撰写详细的“项目模板开发指南”，鼓励社区贡献。

## 6. 总结

本方案通过引入“项目模板”系统，并以“交互式RPG框架”作为旗舰范例，为ComfyTavern构建了一个从“工具”到“应用”的桥梁。通过提供预设的、结构完整的项目（这些项目内部已经配置好了场景、工作流、乃至Agent蓝图），模板系统将平台强大的底层架构（项目、场景、Agent系统）与高层用户体验（交互式应用面板）无缝连接起来。它在不破坏现有核心架构的前提下，极大地提升了用户的易用性和初次体验，为功能的标准化交付和社区生态的构建提供了清晰、可扩展的路径。