# 本地用户系统设计方案 (Local User System Design)

## 1. 目标与核心场景

本设计旨在为应用提供灵活的本地用户管理机制，以适应不同的部署和使用场景。核心目标包括：

1.  **纯本地自用模式 (默认)**:
    *   **场景**: 用户在单台设备上本地运行和使用应用，无需网络共享，追求极致的便捷性。
    *   **特点**: 无需任何用户创建、登录或密码输入，应用启动即用。所有数据归属于一个默认的本地上下文。
    *   **配置**: 通过 [`config.json`](config.json) 设置 `userManagement.multiUserMode: false` 且不设置 `userManagement.accessPasswordHash`。

2.  **个人远程访问模式 (自用模式 + 全局访问密码)**:
    *   **场景**: 用户将部署在本地的应用通过网络（如内网穿透、端口转发）暴露，以便个人从外部设备访问。此时需要在便捷性的基础上增加一层基础的安全防护。
    *   **特点**: 应用仍为单用户数据上下文，但访问时需要输入一个预设的全局访问密码。
    *   **配置**: 通过 [`config.json`](config.json) 设置 `userManagement.multiUserMode: false` 并配置 `userManagement.accessPasswordHash`。

3.  **多用户共享模式 (独立账户认证)**:
    *   **场景**: 应用部署在一台主机上（例如局域网服务器），允许多个用户通过各自的设备独立访问和使用。每个用户拥有自己的账户、密码、配置和数据。
    *   **特点**: 强制用户注册和登录，提供用户级别的数据隔离和初步的管理员角色。
    *   **配置**: 通过 [`config.json`](config.json) 设置 `userManagement.multiUserMode: true`。

- **扩展性**: 为未来可能扩展到更复杂的在线多用户系统奠定基础，但初期仅关注本地化实现。

## 2. 核心机制

### 2.1. 运行模式与配置

- **配置文件**: 应用的全局配置及用户管理模式存储于 [`config.json`](config.json) 文件中。
- **模式判断逻辑**:
    1. 读取 [`config.json`](config.json) 中的 `userManagement.multiUserMode`。
    2. 如果 `multiUserMode` 为 `true`，则激活 **“多用户共享模式”**。
    3. 如果 `multiUserMode` 为 `false` (或配置文件缺失/该字段缺失，均视为 `false`)：
        a. 检查 `userManagement.accessPasswordHash` 是否已配置且非空。
        b. 如果 `accessPasswordHash` 已配置，则激活 **“个人远程访问模式”**。
        c. 如果 `accessPasswordHash` 未配置或为空，则激活 **“纯本地自用模式”** (此为应用的最终默认行为)。

- **[`config.json`](config.json) 示例**:
  ```json
  // [`config.json`](config.json) 中关于用户管理的配置示例
  {
    "userManagement": {
      "multiUserMode": false, // true: 多用户共享模式; false: 自用模式 (纯本地或带全局密码)
      "singleUserPath": "default_user", // 自用模式下，相对于 userData 的路径名
      "accessPasswordHash": null, // 自用模式下的可选全局访问密码哈希 (例如 "bcrypt_hashed_password_string")。如果为 null 或空字符串，则自用模式无需密码。
      // 多用户共享模式下的配置可以在此扩展，例如默认管理员设置等
    }
    // ... 其他全局配置
  }
  ```

### 2.2. 自用模式 (Single-User Mode) - 包含纯本地与个人远程访问

此模式由 `userManagement.multiUserMode: false` 控制。

#### 2.2.1. 纯本地自用模式

- **激活条件**: `multiUserMode: false` 且 `accessPasswordHash` 未设置或为空。
- **目的**: 提供最简化的个人使用体验。
- **行为**:
    - **无认证**: 应用启动时不显示任何登录或密码输入界面。
    - **默认用户上下文**: 所有操作都在一个预定义的“默认用户”上下文中执行。
    - **数据存储**: 根据 `userManagement.singleUserPath` (默认为 "default_user")，数据存储在 `userData/<singleUserPath>/`。
    - `users.json` 文件不被使用。
    - **API 影响**: 用户管理及认证相关的 API (如用户注册、登录、全局密码验证) 在此模式下被禁用或返回特定状态。`/api/users/current` 将始终返回默认用户的基础信息。
    - **管理员角色**: 不适用。

#### 2.2.2. 个人远程访问模式 (自用模式 + 全局访问密码)

- **激活条件**: `multiUserMode: false` 且 `accessPasswordHash` 已设置。
- **目的**: 为个人远程访问提供基础安全防护，同时保持单用户数据的简洁性。
- **行为**:
    - **全局密码认证**:
        - 应用启动或用户首次访问时，必须输入预设的全局访问密码。
        - 后端验证密码哈希。成功后，可建立一个简单的会话（例如，通过设置一个特定的 `HttpOnly` Cookie，标记该浏览器会话已通过全局密码验证）。
    - **默认用户上下文**: 认证成功后，所有操作仍在“默认用户”上下文中执行。
    - **数据存储**: 与纯本地自用模式相同，使用 `singleUserPath`。
    - `users.json` 文件不被使用。
    - **API 影响**:
        - 需要一个 API (例如 `POST /api/auth/verify-global-password`) 用于前端提交全局密码进行验证。
        - `/api/users/current` 在验证成功后返回默认用户信息，并可附加一个已认证状态。
        - 其他用户管理 API (如用户注册、登录) 禁用。
    - **管理员角色**: 不适用。

### 2.3. 多用户共享模式 (Multi-User Shared Mode) - 独立账户认证

此模式由 `userManagement.multiUserMode: true` 激活。

- **目的**: 支持多用户在局域网等共享环境下独立使用应用，提供用户级别的数据隔离和配置。
- **核心特性**:
    - **强制用户认证**: 必须通过用户名和密码进行注册和登录。
    - **独立用户数据**: 每个用户的数据存储在其专属目录 `userData/<user_uuid>/`。
    - **会话管理**: 登录成功后，后端生成安全的会话凭证 (推荐 JWT)，通过 `HttpOnly` Cookie 传递给客户端。
    - **管理员角色**: 第一个成功注册的用户默认为管理员，拥有用户管理等特权。

#### 2.3.1. 用户账户与认证

- **用户注册**:
    - 用户提供唯一的用户名和密码。
    - 后端对密码进行哈希处理 (例如使用 bcrypt 或 Argon2 并加盐) 后存储。
    - 系统为每个用户生成唯一的内部 UID (例如 UUID)。
- **用户登录**:
    - 用户提供用户名和密码。
    - 后端验证凭证。
- **数据存储结构**:
  ```
  userData/
  ├── <user_alpha_uuid>/  // 用户 Alpha 的数据
  │   ├── workflows/
  │   ├── projects/
  │   ├── settings.json   // 用户特定设置
  │   └── ...
  ├── <user_beta_uuid>/   // 用户 Beta 的数据
  │   └── ...
  └── users.json          // 存储用户列表 (username, uid, passwordHash, isAdmin, createdAt 等)
  ```
- **`users.json`**:
    - 在 `userData/` 根目录下维护，用于存储用户账户信息。
    - 示例：
      ```json
      [
        { "username": "Alice", "uid": "uuid-alice-123", "passwordHash": "...", "isAdmin": true, "createdAt": "timestamp" },
        { "username": "Bob", "uid": "uuid-bob-456", "passwordHash": "...", "isAdmin": false, "createdAt": "timestamp" }
      ]
      ```

#### 2.3.2. 管理员角色 (Admin Role)

- **识别**:
    - **首次注册**: 第一个通过系统注册的用户默认为管理员 (在 `users.json` 中标记 `isAdmin: true`)。
    - 后续可通过管理员操作指定其他管理员（如果需要）。
- **权限 (初步)**:
    - **用户管理**: 查看所有用户列表、创建新用户账户、(可选)修改/删除用户账户。
    - **全局应用配置**: 访问和修改应用级别的全局设置 (存储于 [`config.json`](config.json) 或独立的全局配置文件中)。
- **访问控制**: 管理员拥有访问特定管理面板的权限。

## 3. 用户交互流程

### 3.1. 应用首次启动 / 无用户数据

1.  应用检查 [`config.json`](config.json) 确定运行模式。
2.  **纯本地自用模式**:
    a.  系统根据 `singleUserPath` 确定/创建默认用户数据路径。
    b.  直接进入应用主界面。
3.  **个人远程访问模式 (带全局密码)**:
    a.  系统检测到 `accessPasswordHash` 已配置。
    b.  提示用户输入全局访问密码。
    c.  验证密码。成功后进入应用主界面；失败则停留在密码输入界面。
    d.  (首次配置时，可能需要引导用户设置此全局密码，例如通过命令行工具或特定初始化流程)。
4.  **多用户共享模式**:
    a.  应用检测到 `users.json` 不存在或为空。
    b.  提示用户注册第一个账户，此账户将成为管理员。用户需输入用户名和密码。
    c.  系统创建用户记录，哈希密码，生成 UID，创建用户数据目录。
    d.  自动登录该管理员账户，进入应用主界面。

### 3.2. 应用启动 (已存在数据)

1.  应用检查 [`config.json`](config.json) 确定运行模式。
2.  **纯本地自用模式**:
    a.  加载默认用户数据。
    b.  直接进入应用主界面。
3.  **个人远程访问模式 (带全局密码)**:
    a.  提示用户输入全局访问密码。
    b.  验证通过后加载默认用户数据，进入应用主界面。
4.  **多用户共享模式**:
    a.  显示登录页面（可包含注册入口）。
    b.  用户输入用户名和密码进行登录。
    c.  验证成功后，加载该用户的配置和数据，进入应用主界面。
    d.  如果登录用户是管理员，则相关管理功能可用。

### 3.3. 用户注册 (多用户共享模式下)

- 用户通过登录页面的注册入口发起。
- 提供用户名、密码。系统进行验证和创建流程。

### 3.4. 用户注销 / 切换用户 (多用户共享模式下)

- 提供“注销”功能，清除当前用户的会话，返回登录页面。
- “切换用户”即注销后，另一用户重新登录。

## 4. 后端 API

### 4.1. 认证与会话 API

- **个人远程访问模式 (自用模式 + 全局密码)**:
    - `POST /api/auth/verify-global-password`:
        - 请求体: `{ "password": "用户的输入" }`
        - 响应: 成功则设置会话 Cookie，失败则返回错误。
- **多用户共享模式**:
    - `POST /api/auth/register`:
        - 请求体: `{ "username": "...", "password": "..." }`
        - 响应: 成功则创建用户，(可选)自动登录并返回会话 Cookie。
    - `POST /api/auth/login`:
        - 请求体: `{ "username": "...", "password": "..." }`
        - 响应: 成功则设置会话 Cookie (JWT)。
    - `POST /api/auth/logout`:
        - 清除会话 Cookie。

### 4.2. 当前用户信息 API

- `GET /api/users/current` (或 `GET /api/auth/current`):
    - **纯本地自用模式**: 返回固定的默认用户信息对象。
    - **个人远程访问模式**:
        - 若未通过全局密码验证或会话无效: 返回未认证状态或错误。
        - 若已通过全局密码验证: 返回固定的默认用户信息，可附加状态如 `{ ..., isAuthenticatedWithGlobalPassword: true }`。
    - **多用户共享模式**:
        - 若未登录或会话无效: 返回未认证状态或错误。
        - 若已登录: 返回当前登录用户的详细信息 (如 UID, username, isAdmin)。

### 4.3. 管理员 API (仅在多用户共享模式下，且当前用户为管理员时可用)

- `GET /api/admin/users`: 获取所有用户列表的详细信息。
- `POST /api/admin/users`: (管理员) 创建新用户账户。
- `PUT /api/admin/users/{userId}`: (管理员) 修改指定用户信息。
- `DELETE /api/admin/users/{userId}`: (管理员) 删除指定用户。
- `GET /api/admin/settings`: 获取全局应用配置。
- `POST /api/admin/settings`: 更新全局应用配置。

### 4.4. 会话管理 (Cookie)

- **通用原则**:
    - 使用 `HttpOnly` Cookie 存储会话标识，增强安全性。
    - 在 HTTPS 环境下，Cookie 应标记为 `Secure`。
    - `Path=/`，`SameSite=Lax` (或 `Strict`)。
- **个人远程访问模式**: Cookie 可以是一个简单的会话ID，标记已通过全局密码验证。
- **多用户共享模式**: Cookie 存储 JWT 或其他安全的会话令牌，包含用户UID等信息。

## 5. 前端实现要点

- **模式识别**: 前端需要能够从后端（例如通过一个 `/api/app-info` 接口或扩展 `/api/users/current` 的响应）获取当前应用的准确运行模式（纯本地自用、个人远程带密码、多用户共享）。
- **UI 动态调整**:
    - **纯本地自用**: 无任何登录/密码界面，直接展示应用核心功能。
    - **个人远程访问 (带全局密码)**:
        - 若需要认证，显示全局密码输入界面。
        - 无用户列表、用户管理等功能。
    - **多用户共享**:
        - 显示登录/注册界面。
        - 登录后，根据用户是否为管理员，动态显示/隐藏管理面板和相关功能。
        - 无用户选择列表（用户通过登录识别）。
- **状态管理 (Pinia 等)**: 存储当前用户认证状态、用户信息、应用模式等。
- **API 调用**: 根据不同模式调用相应的认证和数据 API。

## 6. 安全性与后续考虑

### 6.1. 密码安全
- **哈希存储**: 所有密码（全局访问密码、用户账户密码）在存储前必须使用强哈希算法（如 bcrypt, Argon2）并加盐。**严禁明文存储密码。**
- **传输安全**: 在生产环境中，所有涉及密码传输的通信必须使用 HTTPS。

### 6.2. 会话安全
- 遵循 Cookie 安全最佳实践 (`HttpOnly`, `Secure`, `SameSite`)。
- JWT (如果用于多用户模式) 应有合理的过期时间，并考虑刷新机制。

### 6.3. 扩展点
- **用户数据导入/导出**: 允许用户（在自用模式或多用户模式下导出自己的数据）导出其数据。
- **“访客”模式 (多用户)**: 一个临时的、不保存数据的用户会话。
- **与未来联网系统的兼容性**: 当前设计为后续扩展到更复杂的认证机制（如 OAuth2）和权限体系奠定基础。
- **细化的权限管理 (多用户)**: 超越简单的“管理员/普通用户”二分法。

## 7. 技术选型与依赖 (保持不变或按需调整)

- **UID 生成**: `uuid` 库 (例如 `bun:uuid`)。
- **密码哈希**: `bcrypt` 或 Bun 内置的密码工具 (如 `Bun.password.hash`)。
- **Cookie 处理 (后端)**: Elysia 框架内置支持。
- **JWT 处理 (如果使用)**: 例如 `jose` 或 `@elysiajs/jwt`。

这个方案通过明确区分三种核心使用场景，力求在不同场景下平衡应用的便捷性、安全性和功能需求。
