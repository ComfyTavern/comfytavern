# Tavern Action Manifest (TAM) 协议

**文档状态**: 具备可实施性。

### 1. 概述

Tavern Action Manifest (TAM) 是一种为 ComfyTavern 平台设计的、标准化的工具调用协议。它旨在提供一个统一、简洁且对大型语言模型（LLM）友好的指令格式，使 Agent、工作流、UI 插件等任何组件都能以相同的方式请求执行工具。

#### 1.1. 设计原则

- **简洁性 (Simplicity)**: 使用最少的规则清晰地表达“做什么”和“用什么参数”。
- **鲁棒性 (Robustness)**: 能够从复杂的文本中被可靠地提取，并内置容错机制以应对 LLM 生成的常见格式偏差。
- **解耦 (Decoupling)**: TAM 协议本身只关注“调用”这一行为的载体。工具的发现、注册、权限管理和具体执行逻辑由平台其他模块负责。
- **可读性 (Readability)**: 格式设计易于人类阅读、手写和调试，同时也便于 LLM 生成。

### 2. 核心语法

#### 2.1. 结构与边界

一个 TAM 调用被包裹在一对明确的边界标记内。解析器会忽略边界标记的大小写及周围的空白字符（包括代码块的 ``` 围栏）。

- **边界标记**:
  ```
  <|[REQUEST_TOOL]|>
  ... 键值对内容 ...
  <|[END_TOOL]|>
  ```

#### 2.2. 键值对格式

- **格式**: `key:»»»value«««`
- **键 (key)**: 描述参数的名称。
- **值 (value)**: 参数的具体内容。可以包含任意字符，支持多行，且**无需任何转义**。这对于传递代码片段、JSON 对象或长篇文本至关重要。
- **分隔符**: `»»»` 和 `«««` 是标准分隔符。解析器具备一定的容错能力，能处理备用分隔符（如 `>>>` 和 `<<<`）或尾部 分隔符缺失的情况，但会产生警告。

#### 2.3. 键名标准化

为了稳健地处理 LLM 可能生成的不同风格的键名，解析器在处理前会对所有键名执行严格的标准化：

1.  移除首尾空白。
2.  转换为全小写。
3.  将所有非字母数字字符（如空格 ` `、连字符 `-`）统一替换为下划线 `_`。
4.  折叠连续的下划线为单个。

**示例**: `File-Path 1`、`filePath_1` 和 `File Path_1` 都会被标准化为 `file_path_1`。

### 3. 关键特性

#### 3.1. 多步骤串行执行

TAM 支持在单个块内定义一个由多个步骤组成的串行工作流，从而减少通信开销。

- **命令**: 使用带编号后缀的 `command_N` (如 `command_1`, `command_2`) 来定义执行步骤。
- **参数**: 每个步骤的参数通过相同的编号后缀与命令关联 (如 `file_path_1` 属于 `command_1`)。
- **执行顺序**: 解析器会根据命令的数字编号从小到大排序并依次执行。

#### 3.2. 异步执行模型

**核心原则：工具的执行模式（同步或异步）是其自身固有的属性，在定义时决定，而非在调用时指定。**

- **工具定义**: 工具在平台注册时，必须声明其是同步还是异步。例如，一个文件写入操作可能是同步的，而一个耗时的图像生成任务则是异步的。
- **执行器行为**: 当执行器收到 TAM 调用时，它会查询工具定义。
  - **同步工具**: 执行器会阻塞并等待其完成，然后返回结果。
  - **异步工具**: 执行器会立即启动任务并返回一个任务句柄（如 `task_id`），任务在后台运行。结果将通过平台级的事件总线（EventBus）在完成后通知调用方。
- **对 LLM 的影响**: LLM 无需关心执行细节，只需按逻辑顺序调用工具即可，极大地简化了任务规划的复杂性。

#### 3.3. 资源引用 (URI)

为了高效传递大型数据（如文件、图像），应使用资源引用（URI）代替内容内联。

- **格式**: `uri_[参数名]_[步骤编号]`
- **示例**: `uri_image_1:»»»fam://project-data/images/input.png«««`
- **说明**: `fam://` 是 ComfyTavern 内部的文件系统协议。执行器负责解析此 URI 并获取实际资源。

### 4. 参数参考

| 分类         | 字段模式                          | 示例                                  | 说明                                                                             |
| :----------- | :-------------------------------- | :------------------------------------ | :------------------------------------------------------------------------------- |
| **执行控制** | `command` / `command_N`           | `command_1:»»»File.Write«««`          | **必需**。指定要执行的工具的唯一 ID。`_N` 用于多步骤调用。                       |
| **执行修饰** | `on_error_N`                      | `on_error_1:»»»continue«««`           | 定义第 N 步出错时的行为。`stop` (默认) 中断整个流程，`continue` 忽略错误并继续。 |
|              | `retry_N`                         | `retry_1:»»»3«««`                     | 指定第 N 步失败后自动重试的次数。                                                |
| **数据处理** | `type_hint_[param]_N`             | `type_hint_payload_2:»»»json«««`      | 为参数值提供类型提示，如 `json`, `base64`。执行器据此进行预处理。默认为 `text`。 |
|              | `uri_[param]_N`                   | `uri_source_file_1:»»»fam://...«««`   | 通过 URI 传递参数值，用于大文件或二进制数据。                                    |
| **共享参数** | `common_[param]`                  | `common_project_id:»»»proj-123«««`    | 定义一个对块内所有步骤都生效的公共参数。可被同名的步骤级参数覆盖。               |
| **元数据**   | `request_id`                      | `request_id:»»»req-abc-123«««`        | 为整个 TAM 块提供唯一标识，用于日志追踪和幂等性控制。                            |
|              | `comment`                         | `comment:»»»Debug note...«««`         | 注释。内容会被解析器忽略，仅用于调试或为人类阅读者提供上下文。                   |
| **普通参数** | `[param_name]` / `[param_name]_N` | `file_path_1:»»»/path/to/file.txt«««` | 传递给工具的标准参数。                                                           |

### 5. 使用示例

#### 5.1. 简单的单步调用

```
<|[REQUEST_TOOL]|>
command:»»»File.ApplyEdit«««
file_path:»»»/path/to/main.js«««
search_string:»»»console.log("old");«««
replace_string:»»»console.log("new");«««
<|[END_TOOL]|>
```

#### 5.2. 复杂的多步工作流

此示例演示了一个包含三步骤的报告生成流程：

1.  调用图像工具生成封面（异步，出错也继续）。
2.  向日志文件追加一行记录。
3.  使用 JSON 负载和之前生成的封面图像（通过 URI 引用）构建最终报告。

```
<|[REQUEST_TOOL]|>
request_id:»»»req-20250805-report«««
common_output_dir:»»»fam://project-x/reports/today«««
comment:»»»生成每日报告的完整流程«««

# 步骤 1: 异步生成封面图，如果失败则跳过
command_1:»»»ImageTool.Generate«««
on_error_1:»»»continue«««
prompt_1:»»»一只戴着宇航头盔的猫头鹰，赛博朋克风格«««
output_uri_1:»»»@{common_output_dir}/cover.png«««

# 步骤 2: 同步写日志
command_2:»»»File.Append«««
file_path_2:»»»@{common_output_dir}/run.log«««
content_2:»»»-- Report generation started at @{timestamp} --«««

# 步骤 3: 构建最终报告
command_3:»»»Report.Build«««
type_hint_payload_3:»»»json«««
payload_3:»»»
{
  "title": "每日运营报告",
  "coverImageUri": "@{common_output_dir}/cover.png",
  "logFileUri": "@{common_output_dir}/run.log",
  "author": "咕咕"
}
«««
<|[END_TOOL]|>
```

_注意: `@{...}` 是一种平台侧的变量替换语法，TAM 本身不负责解析，仅作为纯文本传递。_

#### 5.3. 宽容解析示例

假设 LLM 生成了以下不规范的 TAM 块：

```
<|[REQUEST_TOOL]|>
  # 我的计划
  Command_1: >>>File.Write<<<
  File-Path 1:»»» /logs/today.log «««
  CONTENT1:»»»start…
  another line«««
<|[END_TOOL]|>
```

**解析器处理结果**:

1.  **标准化键名**: `Command_1` → `command_1`, `File-Path 1` → `file_path_1`, `CONTENT1` → `content_1`。
2.  **提取值**: 正确处理了 `>>>...<<<` 和 `»»»...«««` 分隔符，并修剪了值两端的空白。
3.  **忽略注释**: `# 我的计划` 行被解析器忽略，前端UI可以显示注释内容。
4.  **最终产出结构化数据**:
    - `commands[0]`: `{ index: 1, toolId: "File.Write", params: { file_path: "/logs/today.log", content: "start…\nanother line" } }`
    - `warnings`: `["mixed_delimiters_used"]`

### 6. 职责边界

- TAM **仅定义调用载体**。
- 工具的命名空间、参数校验、权限管理、执行逻辑、错误处理与重试策略等，均由平台的**工具管理与执行模块**负责。
- 平台可在不改变 TAM 语法的前提下，独立演进上述能力。

### 7. 最佳实践

- **优先生成规范格式**: 尽管解析器很宽容，但直接生成规范的 TAM 效率最高、最可靠。
- **合并顺序任务**: 将多个有顺序依赖的操作合并到一个 TAM 块的 `command_1/2/3…` 中，以减少通信往返。
- **引用大型数据**: 对于图像、音频或大型 JSON，使用 `uri_*` 字段传递引用，而不是直接内联。
- **善用元数据**: 在手写调试或复杂场景下，使用 `comment` 和 `request_id` 增强可读性和可追溯性。
