# ComfyTavern 移动端分支迁移计划（草案）

## 核心目标

1.  **将后端核心逻辑（节点管理、加载、执行）迁移到 Tauri 前端环境。**
2.  **确保迁移后的执行引擎能够高效、稳定地在前端运行。**
3.  **为“工作流驱动的应用面板”架构奠定基础**，使这些面板能够加载、运行工作流并与之交互。这是移动端的核心用户体验。

## 代码仓库组织

*   Tauri 应用将作为当前主 monorepo 的一部分，创建在 `apps/` 目录下（例如 `apps/comfytavern-tauri`）。
*   共享的核心逻辑（如节点定义、类型、工具函数、核心引擎）将通过 monorepo 的工作区机制被 Tauri 应用引用和打包。

## 初步迁移计划大纲

### 阶段一：核心逻辑解耦与迁移准备

1.  **目标**：将当前后端的 TypeScript 模块（`NodeManager`, `NodeLoader`, `ExecutionEngine` 及其依赖的类型和工具函数）从 Elysia HTTP 上下文中剥离出来，使其成为可以在任何标准 TypeScript/JavaScript 环境中独立运行的库或模块集合。
2.  **步骤**：
    *   识别纯逻辑模块，不直接依赖 Elysia、Bun 特有 API 或复杂的服务器端 I/O。
    *   重构依赖注入：
        *   `ExecutionEngine` 对 `WebSocketManager` 的依赖，替换为抽象的事件通知接口或回调机制。
        *   标记 `NodeLoader` 和 `NodeManager` 中涉及的 `fs` 和 `path` 操作，作为 Tauri 环境中需适配的重点。
    *   考虑将解耦的核心逻辑组织成可被前端直接引用的 `packages`（例如，`@comfytavern/core-engine`），或调整现有 `packages/` 结构。

### 阶段二：Tauri 应用原型搭建与核心逻辑集成

1.  **目标**：搭建一个最小化的 Tauri 应用，并将解耦后的核心逻辑（节点加载、管理、执行）初步集成进去，验证其在 Tauri 环境中的基本可行性。
2.  **步骤**：
    *   创建 Tauri 项目（或在现有前端项目基础上添加 Tauri 支持）。
    *   集成节点加载与管理：
        *   引入 `NodeManager` 和 `NodeLoader`。
        *   适配节点发现：
            *   内置节点：通过构建时生成节点模块列表/清单，让 `NodeLoader` 直接导入。
            *   用户扩展节点：研究使用 Tauri API 读取应用特定数据目录下的节点文件。
        *   适配路径推断：修改 `NodeManager` 中基于文件路径的命名空间推断逻辑，或更多依赖节点定义中显式的 `namespace`。
    *   集成执行引擎：
        *   引入 `ExecutionEngine`。
        *   实现前端内部的事件通知机制（替代原 `WebSocketManager`）。
        *   创建测试界面，手动构建简单工作流数据，调用 `ExecutionEngine.run`，验证执行。
    *   验证简单节点的 `execute` 方法可在前端正确执行。
    *   配置 Tauri 应用的前端构建环境（如 Vite），使其能正确引用和打包 monorepo 中共享的核心逻辑和节点模块。

### 阶段三：前端 UI 适配与“应用面板”架构初步设计

1.  **目标**：将现有的 VueFlow 编辑器 UI 适配到 Tauri 环境中，并开始构思支持“工作流驱动的应用面板”的架构。
2.  **步骤**：
    *   适配编辑器 API 调用：修改 VueFlow 编辑器前端，将对后端 API 的调用改为直接调用前端环境中的 `NodeManager` 和 `ExecutionEngine`。
    *   状态同步：确保编辑器 UI 能通过新的前端内部通信机制正确响应执行引擎的状态更新。
    *   “应用面板”概念验证：
        *   设计简单的“应用面板”定义方式（如 Vue 组件或 HTML/JS 文件组）。
        *   设计工作流与“应用面板”的关联机制。
        *   创建“应用面板”原型（如简单聊天界面或数据显示界面）。
        *   在 Tauri 应用中尝试加载并运行此原型，使其能调用本地 `ExecutionEngine`。
    *   初步思考“应用面板”与 `ExecutionEngine` 的数据交互接口。

### 阶段四：文件管理与持久化适配

1.  **目标**：将在后端处理的工作流和项目文件的保存与加载逻辑，迁移到 Tauri 环境中，使用 Tauri 提供的文件系统 API。
2.  **步骤**：
    *   分析后端关于文件读写的核心逻辑（如 `workflowRoutes.ts`, `projectRoutes.ts`, `projectService.ts`）。
    *   使用 Tauri 的 `fs` API 和对话框 API 重新实现工作流和项目的创建、保存、加载、导入、导出。文件保存到用户选择的位置或应用特定数据目录。
    *   确保前端 UI（编辑器和“应用面板”加载机制）能与新的文件操作函数正确集成。

### 阶段五：细化、测试与文档更新

1.  **目标**：完善所有迁移的功能，进行充分测试，并更新相关文档。
2.  **步骤**：
    *   对所有迁移的模块和功能进行详细测试。
    *   处理复杂节点的 `execute` 方法迁移（适配其后端依赖）。
    *   性能优化。
    *   完善错误处理和用户反馈。
    *   修订项目文档（如 `/.roo/rules/rules.md`），清晰阐述新的架构和“工作流驱动的应用面板”核心理念。

## 迁移计划流程图

```mermaid
graph TD
    A[阶段一: 核心逻辑解耦与迁移准备] --> B(识别纯逻辑模块);
    A --> C(重构依赖注入);
    A --> D(创建/调整共享模块/包);

    E[阶段二: Tauri原型与核心逻辑集成] --> F(创建Tauri项目);
    E --> G(集成节点加载/管理);
    G --> G1(适配节点发现 - 清单/Tauri API);
    G --> G2(适配路径推断/显式namespace);
    E --> H(集成执行引擎);
    H --> H1(实现前端通知机制);
    E --> I(验证节点execute方法);
    E --> I2(配置Vite打包共享模块);

    J[阶段三: 前端UI适配与应用面板架构] --> K(适配编辑器API调用);
    J --> L(状态同步);
    J --> M(应用面板概念验证);
    M --> M1(设计面板定义与关联);
    M --> M2(创建面板原型并运行);
    J --> N(思考面板与引擎交互接口);

    O[阶段四: 文件管理与持久化适配] --> P(分析后端文件操作逻辑);
    O --> Q(使用Tauri API重实现文件操作);
    O --> R(前端UI集成文件操作);

    S[阶段五: 细化、测试与文档更新] --> T(全面测试);
    S --> U(处理复杂节点迁移);
    S --> V(性能优化);
    S --> W(修订项目文档);

    D --> G;
    D --> H;
    I2 --> K;
    M2 --> Q;